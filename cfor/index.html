<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `cfor` crate.">
    <meta name="keywords" content="rust, rustlang, rust-lang, cfor">

    <title>cfor - Rust</title>

    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'></p><script>window.sidebarCurrent = {name: 'cfor', ty: 'mod', relpath: '../'};</script>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Crate <a class='mod' href=''>cfor</a><wbr></span><span class='out-of-band'><a href='stability.html'>[stability]</a> <span id='render-detail'>
            <a id="collapse-all" href="#">[-]</a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-0' href='../src/cfor/lib.rs.html#1-236'>[src]</a></span></h1>
<div class='docblock'><p>A C-style <code>for</code> loop in macro form.</p>

<p>This takes the form <code>cfor!(initialiser; condition; step { body })</code>.</p>

<ul>
<li><code>initialiser</code> is a statement evaluated before any iterations of
the loop. Any variables declared here are scoped to the <code>cfor!</code>
invocation, that is, only usable inside <code>condition</code>, <code>step</code> and
<code>body</code>.</li>
<li><code>condition</code> is an boolean expression evaluated at the start of
each iteration. If it evaluates to <code>false</code> iteration will stop.</li>
<li><code>step</code> is an arbitrary expression which is executed at the end
of each iteration (including if <code>continue</code> is called), before
<code>condition</code> is checked.</li>
</ul>

<p>The initialiser and condition can be empty like C, but the step
cannot unlike C. A <code>for</code> loop with no step is identical to a
<code>while</code> loop.</p>

<p><a href="https://github.com/huonw/cfor/"><em>Source &amp; issue tracker</em></a></p>

<h1 id="when-should-i-use-it?" class='section-header'><a
                           href="#when-should-i-use-it?">When should I use it?</a></h1>
<p><em>Only</em> when <code>cfor!</code> is clearer than the more declarative built-in
<a href="http://doc.rust-lang.org/master/std/iter/">iterators</a>, <a href="http://doc.rust-lang.org/master/std/iter/trait.Iterator.html">their
adaptors</a>
and the <code>for</code> loop. For example, the built-in iterator
functionality is more self-contained so there is less risk of
accidentally writing <code>i</code> in a condition when <code>j</code> was meant (I
personally get bitten by this semiregularly when writing nested
&quot;2D&quot; loops in C).</p>

<p>Furthermore, the adaptor methods linked above allow <a href="http://huonw.github.io/2014/06/10/knn-rust.html">one to
write</a> concise,
performant, reusable &quot;functional&quot; code in a way that is not
possible to achieve using C-style iteration.</p>

<h1 id="how-to-use-it?" class='section-header'><a
                           href="#how-to-use-it?">How to use it?</a></h1>
<p>Add the repository as a normal cargo dependency, and include into
your crate with <code>#[phase(plugin)]</code>. (See examples below.)</p>

<pre><code class="language-toml">[dependencies.cfor]
cfor = &quot;1.0&quot;
</code></pre>

<h1 id="examples" class='section-header'><a
                           href="#examples">Examples</a></h1>
<h2 id="simple" class='section-header'><a
                           href="#simple">Simple</a></h2>
<p>A non-additive condition is not handled extremely naturally by
<code>std::iter</code>, but is straight-forward to handle directly.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span> <span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>cfor</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>cfor</span><span class='macro'>!</span>{<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1</span>; <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>0x1000</span>; <span class='ident'>x</span> <span class='op'>*=</span> <span class='number'>2</span>; {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;power of 2: {}&quot;</span>, <span class='ident'>x</span>);
    }}
}
</pre>

<h2 id="intrabody-condition" class='section-header'><a
                           href="#intrabody-condition">Intrabody condition</a></h2>
<p>If a condition requires some extra computation to be checked (or
if there is some code that should always be evaluated, even if the
condition will be <code>false</code> for a given iteration), the condition in
the <code>cfor</code> header can be omitted.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span> <span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>cfor</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>cfor</span><span class='macro'>!</span>{<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1</span>; ; <span class='ident'>x</span> <span class='op'>*=</span> <span class='number'>2</span>; {
        <span class='comment'>// ... setup ...</span>
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;handling power of 2: {}&quot;</span>, <span class='ident'>x</span>);

        <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>0x1000</span> { <span class='kw'>break</span> }

        <span class='comment'>// ... further handling ...</span>
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;handling power of 2: {}&quot;</span>, <span class='ident'>x</span>);
    }}
}
</pre>

<h2 id="out-of-loop-initialisation" class='section-header'><a
                           href="#out-of-loop-initialisation">Out-of-loop initialisation</a></h2>
<p>Sometimes one may wish to have access to a variable outside the
loop after it finishes so it has to be declared outside the loop,
or one may be iterating over some presupplied/-computed value so
there is no meaningful additional initialisation possible. The
initialisation expression can be safely omitted in this case.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span> <span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>cfor</span>;

<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>rand</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>1u16</span>;

    <span class='macro'>cfor</span><span class='macro'>!</span>{; <span class='ident'>x</span> <span class='op'>&lt;</span> <span class='number'>0x1000</span>; <span class='ident'>x</span> <span class='op'>*=</span> <span class='number'>2</span>; {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;power of 2: {}&quot;</span>, <span class='ident'>x</span>);

        <span class='comment'>// sometimes quit early</span>
        <span class='kw'>if</span> <span class='ident'>x</span> <span class='op'>&gt;</span> <span class='ident'>rand</span>::<span class='ident'>random</span>() { <span class='kw'>break</span> }
    }}

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;actually stopped at {}&quot;</span>, <span class='ident'>x</span>);
}
</pre>

<h1 id="handling-continue" class='section-header'><a
                           href="#handling-continue">Handling <code>continue</code></a></h1>
<p>(Or, &quot;why is the macro so complicated?&quot;)</p>

<p>Special effort is made to ensure that <code>continue</code> acts correctly, a
naive macro defined as follows will cause <code>continue</code> to also skip
evaluating <code>step</code>, likely leading to undesirable behaviour like
infinite loops.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='comment'>// WARNING: this is broken.</span>
<span class='macro'>macro_rules</span><span class='macro'>!</span> <span class='ident'>bad_cfor</span> {
    (<span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>init</span>: <span class='ident'>stmt</span>; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>cond</span>: <span class='ident'>expr</span>; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>step</span>: <span class='ident'>expr</span>; <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>: <span class='ident'>block</span>) <span class='op'>=&gt;</span> {
        {
            <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>init</span>;
            <span class='kw'>while</span> <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>cond</span> {
                <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>body</span>;

                <span class='macro-nonterminal'>$</span><span class='macro-nonterminal'>step</span>;
            }
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>true_counter</span> <span class='op'>=</span> <span class='number'>0</span>;

    <span class='macro'>bad_cfor</span><span class='macro'>!</span>{<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>i</span> <span class='op'>=</span> <span class='number'>0</span>; <span class='ident'>i</span> <span class='op'>&lt;</span> <span class='number'>10</span>; <span class='ident'>i</span> <span class='op'>+=</span> <span class='number'>1</span>; {

        <span class='comment'>// manually avoid the infinite loop</span>
        <span class='kw'>if</span> <span class='ident'>true_counter</span> <span class='op'>&gt;=</span> <span class='number'>50</span> { <span class='kw'>break</span> }
        <span class='ident'>true_counter</span> <span class='op'>+=</span> <span class='number'>1</span>;

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;i = {}&quot;</span>, <span class='ident'>i</span>);
        <span class='comment'>// try to skip just i == 4</span>
        <span class='kw'>if</span> <span class='ident'>i</span> <span class='op'>==</span> <span class='number'>4</span> {
            <span class='comment'>// but this skips the i += 1 leaving us</span>
            <span class='comment'>// on i == 4 forever.</span>
            <span class='kw'>continue</span>
        }
        <span class='comment'>// ...more code...</span>
    }}
}
</pre>

<p>This is invoked in the same manner as <code>cfor!</code>, but, if <code>$body</code>
contains a <code>continue</code>, the <code>$step</code> at the end of the loop body
will never be evaluated.</p>

<h1 id="handling-multiple-initializations-and-steps" class='section-header'><a
                           href="#handling-multiple-initializations-and-steps">Handling multiple initializations and steps</a></h1>
<p>Like C loops, <code>cfor!</code> supports specfying multiple initializations and steps seperated by a comma.</p>
<pre id='rust-example-rendered' class='rust '>
<span class='attribute'>#[<span class='ident'>macro_use</span>]</span> <span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>cfor</span>;

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='macro'>cfor</span><span class='macro'>!</span>{<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>x</span> <span class='op'>=</span> <span class='number'>0</span>, <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>y</span> <span class='op'>=</span> <span class='ident'>x</span>; <span class='ident'>x</span> <span class='op'>&lt;=</span> <span class='number'>10</span> <span class='op'>&amp;&amp;</span> <span class='ident'>y</span> <span class='op'>&lt;=</span> <span class='number'>100</span>; <span class='ident'>x</span> <span class='op'>+=</span> <span class='number'>1</span>, <span class='ident'>y</span> <span class='op'>+=</span> <span class='number'>10</span>; {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;x: {}, y: {}&quot;</span>, <span class='ident'>x</span>, <span class='ident'>y</span>);
    }}
}
</pre>
</div><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='macro' href='macro.cfor!.html'
                               title='cfor::cfor!'>cfor!</a></td>
                        <td class='docblock short'><p>A C-style <code>for</code> loop in macro form.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "cfor";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script async src="../search-index.js"></script>
</body>
</html>